{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","target","targetOffset","offset","length","toBuffer","copy","_buffer","Buffer","from","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","alloc","iRead","iWrite","buf","undefined","chunk","Math","min","StreamBuf","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","full","push","_pipe","write","pipe","Promise","resolve","all","_writeToBuffers","inLen","callback","Function","nop","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","read","eod","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","Error","wrap","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable max-classes-per-file */\nconst Stream = require('stream');\n\nconst utils = require('./utils');\nconst StringBuf = require('./string-buf');\n\n// =============================================================================\n// data chunks - encapsulating incoming data\nclass StringChunk {\n  constructor(data, encoding) {\n    this._data = data;\n    this._encoding = encoding;\n  }\n\n  get length() {\n    return this.toBuffer().length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    if (!this._buffer) {\n      this._buffer = Buffer.from(this._data, this._encoding);\n    }\n    return this._buffer;\n  }\n}\n\nclass StringBufChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data.toBuffer();\n  }\n}\n\nclass BufferChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data;\n  }\n}\n\n// =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\nclass ReadWriteBuf {\n  constructor(size) {\n    this.size = size;\n    // the buffer\n    this.buffer = Buffer.alloc(size);\n    // read index\n    this.iRead = 0;\n    // write index\n    this.iWrite = 0;\n  }\n\n  toBuffer() {\n    if (this.iRead === 0 && this.iWrite === this.size) {\n      return this.buffer;\n    }\n\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  }\n\n  get length() {\n    return this.iWrite - this.iRead;\n  }\n\n  get eod() {\n    return this.iRead === this.iWrite;\n  }\n\n  get full() {\n    return this.iWrite === this.size;\n  }\n\n  read(size) {\n    let buf;\n    // read size bytes from buffer and return buffer\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if (size === undefined || size >= this.length) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    }\n\n    // otherwise return a chunk\n    buf = Buffer.alloc(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  }\n\n  write(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    const size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  }\n}\n\n// =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\n\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\n// integration tests\nconst StreamBuf = function(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = [];\n\n  // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n  this.batch = options.batch || false;\n\n  this.corked = false;\n  // where in the current writable buffer we're up to\n  this.inPos = 0;\n\n  // where in the current readable buffer we've read up to\n  this.outPos = 0;\n\n  // consuming pipe streams go here\n  this.pipes = [];\n\n  // controls emit('data')\n  this.paused = false;\n\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n      case 1:\n        return this.buffers[0].toBuffer();\n      default:\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  _getWritableBuffer() {\n    if (this.buffers.length) {\n      const last = this.buffers[this.buffers.length - 1];\n      if (!last.full) {\n        return last;\n      }\n    }\n    const buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  async _pipe(chunk) {\n    const write = function(pipe) {\n      return new Promise(resolve => {\n        pipe.write(chunk.toBuffer(), () => {\n          resolve();\n        });\n      });\n    };\n    await Promise.all(this.pipes.map(write));\n  },\n  _writeToBuffers(chunk) {\n    let inPos = 0;\n    const inLen = chunk.length;\n    while (inPos < inLen) {\n      // find writable buffer\n      const buffer = this._getWritableBuffer();\n\n      // write some data\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  async write(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n    callback = callback || utils.nop;\n\n    // encapsulate data into a chunk\n    let chunk;\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else {\n      // assume string\n      chunk = new StringChunk(data, encoding);\n    }\n\n    // now, do something with the chunk\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n        while (!this.corked && this.buffers.length > 1) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        await this._pipe(chunk);\n        callback();\n      } else {\n        this._writeToBuffers(chunk);\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n      this.emit('readable');\n    }\n\n    return true;\n  },\n  cork() {\n    this.corked = true;\n  },\n  _flush(/* destination */) {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork() {\n    this.corked = false;\n    this._flush();\n  },\n  end(chunk, encoding, callback) {\n    const writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n        this.pipes.forEach(pipe => {\n          pipe.end();\n        });\n        this.emit('finish');\n      }\n    };\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(size) {\n    let buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        const first = this.buffers[0];\n        const buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    this.paused = false;\n  },\n  isPaused() {\n    return !!this.paused;\n  },\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n  unshift(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  },\n});\n\nmodule.exports = StreamBuf;\n"],"file":"stream-buf.js"}